from abc import ABC, abstractmethod

# Is this overengineered? Yes.
# Is this worth it? Also yes.

class BaseType(ABC):
    condition: str | None

    def __init__(self):
        super()
        self.condition = None

    @abstractmethod
    def get_c_type(self):
        ...

    @abstractmethod
    def generate_parse_code(self, indent: str):
        '''Parse data from the value variable and store in the x variable'''
        ...

    def generate_insert_code(self, c_key: str, indent: str):
        '''Transfer data from the x variable to the config struct.'''
        return f"{indent}conf->{c_key} = x;"

    def require(self, condition: str):
        '''Check a condition before accepting a value. The value is available through a variable called x.'''
        self.condition = condition
        return self

class string(BaseType):
    def get_c_type(self):
        return "char *"

    def generate_parse_code(self, indent: str):
        return f"{indent}x = value;"

    def generate_insert_code(self, c_key: str, indent: str):
        return f'''{indent}free(conf->{c_key});
{indent}conf->{c_key} = strdup(x);''';

class bool(BaseType):
    def get_c_type(self):
        return "bool "

    def generate_parse_code(self, indent: str):
        return f"{indent}if (!config_parse_bool(&x, value)) {{ return; }}"

class int(BaseType):
    def get_c_type(self):
        return "int "

    def generate_parse_code(self, indent: str):
        return f"{indent}if (!config_parse_int(&x, value)) {{ return; }}"

def config(props: dict[str, BaseType | dict[str, BaseType]]):
    indent = "    "

    declaration_parts = [
        "#pragma once",
        "// This file is automatically generated by the Python scripts in the config/ directory. Do not edit manually.",
        "",
        "typedef struct {",
    ]

    definition_parts = [
'''#include <spaceshot-config-struct-decl.h>
#include <errno.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// This file is automatically generated by the Python scripts in the config/ directory. Do not edit manually.",

// logging function, modified from log.c
static void config_warn(const char *format, ...) {
    const char *PREFIX = "warning(config): ";
    char wrapped_format[strlen(PREFIX) + strlen(format) + 1];
    strcpy(wrapped_format, PREFIX);
    strcat(wrapped_format, format);

    va_list args;
    va_start(args);
    vprintf(wrapped_format, args);
    va_end(args);
}

// type parser functions
static bool config_parse_bool(bool *x, char *value) {
    if (strcmp(value, "true") == 0) {
        *x = true;
    } else if (strcmp(value, "false") == 0) {
        *x = false;
    } else {
        config_warn("invalid boolean %s", value);
        return false;
    }
    return true;
}

static bool config_parse_int(int *x, char *value) {
    char *endptr;
    errno = 0;
    *x = strtol(value, &endptr, 0);
    if (value[0] == '\\0' || *endptr != '\\0' || errno) {
        config_warn("invalid integer %s", value);
        return false;
    }
    return true;
}

void config_parse_entry(void *data, const char *section, const char *key, char *value) {
    Config *conf = data;
'''
    ]

    def generate_condition_check(value: BaseType, indent: str):
        return f'''{indent}if (!({value.condition})) {{
{indent}    config_warn("value %s for key %s is invalid (needs to be %s)", value, key, "{value.condition}");
{indent}    return;
{indent}}}'''

    def handle_item(key: str, value: BaseType, section: str | None, indent: str):
        c_key = key.replace("-", "_")
        qualified_c_name = c_key if section is None else f"{section.replace("-", "_")}.{c_key}"

        # this uses key and not qualified_c_name because names need to be unqualified in the struct definition
        declaration_parts.append(f"{indent}{value.get_c_type()}{c_key};")
        definition_parts.append(f'''{indent}if (strcmp(key, "{key}") == 0) {{
{indent}    {value.get_c_type()}x;
{value.generate_parse_code(indent + "    ")}
{generate_condition_check(value, indent + "    ") if value.condition else ""}
{value.generate_insert_code(qualified_c_name, indent + "    ")}
{indent}}}''')

    sections: list[tuple[str, dict[str, BaseType]]] = []
    definition_parts.append(f"{indent}if (section == NULL) {{")
    for key, value in props.items():
        if isinstance(value, dict):
            sections.append((key, value))
        else:
            handle_item(key, value, None, indent + "    ")
    definition_parts.append(f"{indent}}}")

    for sec_name, section in sections:
        declaration_parts.append(f"{indent}struct {{")
        definition_parts.append(f'{indent}if (strcmp(section, "{sec_name}") == 0) {{')

        for subkey, subvalue in section.items():
            handle_item(subkey, subvalue, sec_name, indent + "    ")

        declaration_parts.append(f"{indent}}} {key.replace("-", "_")};")
        definition_parts.append(f"{indent}}}")

    declaration_parts.append("} Config;\n")
    definition_parts.append("}\n")

    config_h = str.join("\n", declaration_parts)
    config_c = str.join("\n", definition_parts)

    return config_c, config_h
